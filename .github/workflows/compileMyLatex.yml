name: Build LaTeX document and Release PDF
# Version: 07142024
#
# Is executed at gooTeX script's prompt. 
# ############################
#      Pamela M. Marcum      #
#  first created: 07/14/2024 #
# ############################
# Controls when the action will run.
# https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions
# https://mrturkmen.com/posts/build-release-latex/
# https://github.com/PHPirates/travis-ci-latex-pdf/blob/master/.github/workflows/texlive.yml
# https://github.com/teatimeguest/setup-texlive-action  includes caching

on:
  workflow_dispatch:
    inputs: 
      file2compile:
         description: "Name of .tex file to compile, without the .tex part"
         required: true
         default: "main"        
         
jobs:
  # followed: https://dev.to/dessygil/
  #   how-to-automatically-update-resume-on-your-personal-site-from-overleaf-1fld
  # https://superuser.com/questions/1455483/how-to-get-wsl-use-git-bash-to-run-a-latexmk-command
  # https://www.overleaf.com/learn/latex/TeX_engine_command_line_options_for_pdfTeX%2C_XeTeX_and_LuaTeX
  build_latex:
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      # Give the default GITHUB_TOKEN write permission to commit and push the changed files back to the repository.
      contents: write
      
    steps:
      - name: Clone repo
        uses: actions/checkout@v4

      - name: Remove old status note and pdf file
        id: removeOldStatusAndPdf
        run: |
          rm -f "${{ github.event.inputs.file2compile }}_out.txt"
          rm -f "${{ github.event.inputs.file2compile }}.pdf"
        continue-on-error: true

      - name: Commit the modified folder and put the change
        run: |
          git config --global user.email "email@gmail.com"
          git config --global user.name "github actions"
          git add .
          git commit -m "Removing previous status and pdf files"
          git push
        continue-on-error: true
        
      # https://tex.stackexchange.com/questions/245982/differences-between-texlive-packages-in-linux
      # https://www.overleaf.com/learn/latex/TeX_engine_command_line_options_for_pdfTeX%2C_XeTeX_and_LuaTeX
      # https://github.com/teatimeguest/setup-texlive-action/tree/v3.3.0
      - name: Install texlive
        uses: teatimeguest/setup-texlive-action@v3
        with:
          packages:
            scheme-basic
            collection-mathscience
            collection-bibtexextra
            collection-fontutils
          cache: true
            
      - name: Compile paper
        id: compilation
        run: |
          latexmk -bibtex -f -g -pdf -time -file-line-error -view=none -synctex=1 -interaction=nonstopmode ${{ github.event.inputs.file2compile }}.tex
        continue-on-error: true

      - name: Get timestamp
        id: date
        run: |
          echo "OUTFILE=${{ github.event.inputs.file2compile }}_out.txt" >> $GITHUB_ENV
          echo "PDFFILE=${{ github.event.inputs.file2compile }}.pdf" >> $GITHUB_ENV
          echo "TIMESTAMP=$(date +'%Y-%m-%dT%H:%M:%SZ') $(($(date +%s%N)/1000000))" >> $GITHUB_ENV
        continue-on-error: true

      - name: Capture compilation output
        id: compileWarnings
        # remove lines in the output that are unrelated to the latex compilation itself
        # First, move lines that should have been the ending of the previous line, to the end of that previous line
        run: |
          # ===================================================================================================================
          # ========================  make sure that all lines related to a sentence are all smooshed together into single line
          sed ':a;N;$!ba;s/\n/\x0/g' ${{ github.event.inputs.file2compile }}.log > new.log
          # ===================================================================================================================
          # ======================== make a new line character after each period
          rm -f tmp.txt && touch tmp.txt && sed -r 's/^( *)\x0( *)\\\\/\1\2/g' new.log >> tmp.txt && mv -f tmp.txt new.log
          touch tmp.txt && sed -r 's/\x0\x0\x0*/\x0\n\x0/g' new.log >> tmp.txt && mv -f tmp.txt new.log
          touch tmp.txt && sed -r 's/\x0 *\\/\x0\n\\/g' new.log >> tmp.txt && mv -f tmp.txt new.log
          touch tmp.txt && sed -r 's/\. *\x0 *\) *\x0/\.\)\n\x0/g' new.log >> tmp.txt && mv -f tmp.txt new.log
          touch tmp.txt && sed -r 's/\. *\x0 *(\) *[\)]*) *\x0/\.\)\1\n\x0/g' new.log >> tmp.txt && mv -f tmp.txt new.log
          touch tmp.txt && sed -r 's/\. *\x0/\.\n/g' new.log >> tmp.txt && mv -f tmp.txt new.log
          touch tmp.txt && sed -r 's/^ *\x0//g' new.log >> tmp.txt && mv -f tmp.txt new.log
          touch tmp.txt && sed -r 's/\x0//g' new.log >> tmp.txt && mv -f tmp.txt new.log
          touch tmp.txt && sed -r 's/  */ /g' new.log >> tmp.txt && mv -f tmp.txt new.log
          mv -f new.log ${{ github.event.inputs.file2compile }}_full.log
          echo "-----------------------------------------------------"
          echo "       FULL, UNPROCESSED COMPILATION OUTPUT"
          echo "-----------------------------------------------------"
          #cat ${{ github.event.inputs.file2compile }}_full.log
          # ===================================================================================================================
          # ====================================  Set up an array that will hold all the errors and warnings listed in the _full.log
          warnErrArr=()
          # ====================================
          # ============= get the errors (in log, labelled as "LaTeX Error") that should make the pdf file not render. 
          readarray -t res < <(grep -E "LaTeX Error" ${{ github.event.inputs.file2compile }}_full.log)
          for (( i=0; i<${#res[@]}; i++ )); do
             warnErrArr[${#warnErrArr[@]}]="${res[$i]}"
          done
          # ====================================
          # ============= now get the warnings, but note that some of the warnings are actually errors (like figure files that are mispelled) and need to 
          # be consolidated with the associated line in the error section here
          readarray -t res < <(grep -E "LaTeX Warning" ${{ github.event.inputs.file2compile }}_full.log)
          for (( i=0; i<${#res[@]}; i++ )); do
             warnErrArr[${#warnErrArr[@]}]="${res[$i]}"
          done
          # ====================================
          # ============= take a look at the bib tex errors
          readarray -t res < <(grep -E "^Package natbib Warning\: Citation" ${{ github.event.inputs.file2compile }}_full.log)
          for (( i=0; i<${#res[@]}; i++ )); do
             warnErrArr[${#warnErrArr[@]}]="${res[$i]}"
          done
          # ====================================
          # ===================== Now add the relevant line number to front of each error/warning line that specifies a line number
          for (( i=0; i<${#warnErrArr[@]}; i++ )); do
             line="${warnErrArr[$i]}"
             if [[ "$(echo "$line" | grep -q -E "on input line [0-9]")$?" == 0 ]]; then
                linenum=$(echo $line | sed -r 's/^.*on input line ([0-9][0-9]*).*/\1/')
                blanks="$(echo "$line" | sed -r 's/ZZ/ /g')"
                if [[ "$(echo "$line" | grep -q -E "LaTeX Error")$?" == 0 ]]; then
                    tmp="$linenum-ERROR-$blanks" 
                elif [[ "$(echo "$line" | grep -q -E "natbib")$?" == 0 ]]; then
                    tmp="$linenum-BIB-$blanks"
                else
                    tmp="$linenum-WARNING-$blanks"
                fi
             elif [[ "$(echo "$line" | grep -q -E "^\.\/${{ github.event.inputs.file2compile }}.tex\:[0-9][0-9]*\:")$?" == 0 ]]; then
                linenum=$(echo $line | sed -r 's/^\.\/[^:]*\:([0-9][0-9]*).*/\1/')
                blanks="$(echo "$line" | sed -r 's/ZZ/ /g')"
                if [[ "$(echo "$line" | grep -q -E "LaTeX Error")$?" == 0 ]]; then
                    tmp="$linenum-ERROR-$blanks" 
                elif [[ "$(echo "$line" | grep -q -E "natbib")$?" == 0 ]]; then
                    tmp="$linenum-BIB-$blanks"
                else
                    tmp="$linenum-WARNING-$blanks"
                fi
             else
                blanks="$(echo "$line" | sed -r 's/ZZ/ /g')"
                if [[ "$(echo "$line" | grep -q -E "LaTeX Error")$?" == 0 ]]; then
                    tmp="0-ERROR-$blanks" 
                elif [[ "$(echo "$line" | grep -q -E "natbib")$?" == 0 ]]; then
                    tmp="0-BIB-$blanks"
                else
                    tmp="0-WARNING-$blanks"
                fi
             fi
             echo " "
             echo " 166 ==============================>>>>>>> tmp: $tmp"
             warnErrArr[$i]="$tmp"
          done
          echo " "
          echo " "
          echo "169"
          printf '%s\n' "${warnErrArr[@]}"
          # ====================================
          # ============== sort and remove redundances in the error/warning list
          sorted=($(printf '%s\n' "${warnErrArr[@]}" | sort -r -t- -g -k1,1n -k2 -s))
          echo "174"
          printf '%s\n' "${sorted[@]}"
          # ##################################################################################################
          #                        now process the list of warnings/errors just gathered
          # ##################################################################################################
          # ==================================== put in a timestamp at the top of file to become final version of log output
          echo "${{ env.TIMESTAMP }}" > tout.txt
          echo "" >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          echo "              ERRORS IN ${{  github.event.inputs.file2compile }}.tex" >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          errors=""
          for (( i=0; i<${#sorted[@]}; i++ )); do
            line="${sorted[$i]}"
            if [[ "$(echo "$line" | grep -q -E "-ERROR-")$?" == 0 ]]; then
               echo "189-----------------> found the next error to process: $errors"
               errors="$line"
               break
            fi
          done
          echo "194================================> the error is $errors"
          # if there were no errors, then put 'none'
          if [ $errors -eq "" ]; then
            echo "      none" >> tout.txt
          fi
          while  [ $errors -ne "" ]; do
            linenum=$(echo "$errors" | sed -r 's/^([0-9][0-9]*)-.*/\1/')
            echo "201 linenum $linenum"
            if [[ $linenum > 0 ]]; then
               # look for all occurances of this line number in the error/warning list
               for (( i=0; i<${#sorted[@]}; i++ )); do
                  echo "205   ${sorted[$i]}"
                  #if [[ "$(echo "${sorted[$i]}" | grep -q -E "^$linenum-")$?" == 0 ]]; then
                  #   line="$(echo "${sorted[$i]}" | sed -r 's/^[0-9][0-9]*-[A-Z]-[A-Z]*-//' | sed -r 's/ZZ/ /g')"
                  #   echo $line >> tout.txt
                  #   # remove this item from the list
                  #   unset sorted[$i]
                  #   echo "the match to the line $line"
                  #fi
               done
               # now look up the line in the .tex file and place underneath
               echo "215  Line #$linenum ----------------------- " >> tout.txt
               head -n $linenum ${{ github.event.inputs.file2compile }}.tex | tail -1 >> tout.txt
            else
               echo "218  there is no line number"
               # look up where this line is in the list and remove it from the list
               for (( i=0; i<${sorted[@]}; i++ )); do
                  echo "221  ${sorted[$i]}"
                  #if [[ "${sorted[$i]}" = "$errors" ]]; then
                  #   line="$(echo "${sorted[$i]}" | sed -r 's/^[0-9][0-9]*-[A-Z]-[A-Z]*-//' | sed -r 's/ZZ/ /g')"
                  #   echo "there is a match, here it is: $line"
                  #   echo $line >> tout.txt
                  #   # remove from list
                  #   unset sorted[$i]
                  #fi
               done
            fi
            sorted=("${sorted[@]}")
            echo "232  after removing the now-procesed lines, heres the list"
            printf '%s\n' "${sorted[@]}"
            # See if any more errors remain in the list and need to be processed in the next loop iteration
            errors=""
            for (( i=0; i<${#sorted[@]}; i++ )); do
               line="${sorted[$i]}"
               if [[ "$(echo $line | grep -q -E "-ERROR-")$?" == 0 ]]; then
                  errors=$line
                  break
               fi
            done
            errors=""
            echo "at the end of the loop, here is the next error: $errors"
            echo "-------------------------------------------------------------------------" >> tout.txt
          done
          echo "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
          cat tout.txt
          echo "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
          echo "" >> tout.txt
          #echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          #echo "              WARNINGS IN ${{  github.event.inputs.file2compile }}.tex" >> tout.txt
          #echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          #warnings=""
          #for (( i=0; i<${#sorted[@]}; i++ )); do
          #  line="${sorted[$i]}"
          #  if [[ "$(echo "$line" | grep -q -E "-WARNING-")$?" == 0 ]]; then
          #     warnings="$line"
          #     break
          #  fi
          #done
          #echo "================================> the warning is $warnings"
          ## if there were no warnings, then put 'none'
          #if [ $warnings -eq "" ]; then
          #  echo "      none" >> tout.txt
          #fi
          #while  [ $warnings -ne "" ]; do
          #  linenum=$(echo "$warnings" | sed -r 's/^([0-9][0-9]*)-.*/\1/')
          #  if [[ $linenum > 0 ]]; then
          #     # look for all occurances of this line number in the error/warning list
          #     for (( i=0; i<${#sorted[@]}; i++ )); do
          #        if [[ "$(echo "${sorted[$i]}" | grep -q -E "^$linenum-")$?" == 0 ]]; then
          #           line="$(echo "${sorted[$i]}" | sed -r 's/^[0-9][0-9]*-[A-Z]-[A-Z]*-//' | sed -r 's/ZZ/ /g')"
          #           echo $line >> tout.txt
          #           # remove this item from the list
          #           unset sorted[$i]
          #        fi
          #     done
          #     # now look up the line in the .tex file and place underneath
          #     echo "Line #$linenum ----------------------- " >> tout.txt
          #     head -n $linenum ${{ github.event.inputs.file2compile }}.tex | tail -1 >> tout.txt
          #  else
          #     # look up where this line is in the list and remove it from the list
          #     for (( i=0; i<${sorted[@]}; i++ )); do
          #        if [[ "${sorted[$i]}" = "$warnings" ]]; then
          #           line="$(echo "${sorted[$i]}" | sed -r 's/^[0-9][0-9]*-[A-Z]-[A-Z]*-//' | sed -r 's/ZZ/ /g')"
          #           echo $line >> tout.txt
          #           # remove from list
          #           unset sorted[$i]
          #        fi
          #     done
          #  fi
          #  sorted=("${sorted[@]}")
          #  echo "after removing the now-procesed lines, heres the list"
          #  printf '%s\n' "${sorted[@]}"
          #  # See if any more errors remain in the list and need to be processed in the next loop iteration
          #  warnings=""
          #  for (( i=0; i<${#sorted[@]}; i++ )); do
          #     line="${sorted[$i]}"
          #     if [[ "$(echo $line | grep -q -E "-WARNING-")$?" == 0 ]]; then
          #        warnings=$line
          #        break
          #     fi
          #  done
          #  echo "at the end of the loop, here is the next error: $warnings"
          #  echo "-------------------------------------------------------------------------" >> tout.txt
          #done          
          #echo "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"
          #cat tout.txt
          #echo "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"
          #echo "" >> tout.txt
          #echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          #echo "              CITATION ISSUES IN ${{  github.event.inputs.file2compile }}.tex " >> tout.txt
          #echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          #rm -f biberrs.txt && touch biberrs.txt
          #grep -E "^[0-9][0-9]* BIB " warningError.txt >> biberrs.txt
          #if [ $(wc -c < "biberrs.txt") -eq 0 ]; then
          #  echo "      none" >> tout.txt
          #fi
          #while  [ $(wc -c < "biberrs.txt") -gt 0 ]; do
          #  line="$(head -1 biberrs.txt)"
          #  linenum=$(echo $line | sed -r 's/^([0-9][0-9]*) .*/\1/')
          #  if [[ $linenum > 0 ]]; then
          #     # look for all occurances of this line number in the file
          #     rm -f tmp.txt && touch tmp.txt && grep -E "^$linenum " warningError.txt >> tmp.txt
          #     while IFS= read -r ln; do
          #        modLine=$(echo $ln | sed -r 's/^[0-9][0-9]* [A-Z][A-Z]* //')
          #        echo $modLine >> tout.txt
          #        # remove these other lines from warningError.txt
          #        rm -f cp.txt && grep -v "$ln" warningError.txt >> cp.txt && mv -f cp.txt warningError.txt
          #     done < tmp.txt
          #     # now look up the line in the .tex file and place underneath
          #     echo "Line #$linenum ----------------------- " >> tout.txt
          #     head -n $linenum ${{ github.event.inputs.file2compile }}.tex | tail -1 >> tout.txt
          #  fi
          #  # now look for more bib errs
          #  rm -f biberrs.txt && touch biberrs.txt
          #  grep -E "^[0-9][0-9]* ERROR " warningError.txt >> biberrs.txt
          #  echo "-------------------------------------------------------------------------" >> tout.txt
          #done
          #echo "***************************************************************************************"
          #cat tout.txt
          #echo "***************************************************************************************"
          #echo " " 
          #echo " " 
          #echo " "
          #echo "(((((((((((((((((("
          #cat warningError.txt
          #echo "))))))))))))))))))"
          ## https://stackoverflow.com/questions/57788813/grep-return-0-if-no-match
          ## squash.io/extracting=numbers-from-strings-in-bash
          ## https://stackoverflow.com/questions/17883661/how-to-extract-numbers-from-a-string
          ## https://stackoverflow.com/questions/2624300/save-part-of-matching-pattern-to-variable
          ### determine if there were no errors, meaning that errors.txt is empty file. If so, place
          ### the word none under the banner of this section in output file. But if there were errors, 
          ### then remove the pdf file so that the pdf file that gets shown in gooTeX is the compilation errors
          ### rather than a mangled pdf. 
          ##echo "" >> tout.txt
          ##echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          ##echo "              LIST OF REFERENCES IN ${{ github.event.inputs.file2compile }}.tex" >> tout.txt
          ##echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          ##grep -e '[eE]rror' -e '[wW]arning' allout.txt > tmptmp1.txt || touch tmptmp1.txt
          ##grep -i ': citation' tmptmp1.txt > tmptmp2.txt || touch tmptmp2.txt
          ##grep -i 'undefined' tmptmp2.txt > tmptmp3.txt || touch tmptmp3.txt
          ##grep -Eo '`[^ ]+' tmptmp3.txt > tmptmp4.txt || touch tmptmp4.txt
          ##cat tmptmp4.txt | sed -r 's/`//g' | sed -r "s/'//g" > tmptmp5.txt
          #sort tmptmp5.txt | uniq >> tout.txt
          #if [ $(wc -c < "tmptmp5.txt") -eq 0 ]; then
          #  echo "      none" >> tout.txt
          #fi  
          #rm -f tmptmp*.txt
          echo ""
          echo ""
          echo "=========================================================================================================="
          cat tout.txt
          echo "==========================================================================================================="
          echo ""
          #mv tout.txt ${{ github.event.inputs.file2compile }}_out.txt
        continue-on-error: true

      - name: Convert errors to PDF file
        #if: ${{ always() && hashFiles('thereAreErrors.txt') }}
        run: |
          echo " "
          echo "========"
          #  # install htmldoc, which apparently is not an inherent command in Ubuntu
          #  sudo apt-get install htmldoc -y
          #  # create a .html file from the out.txt file, then convert the html to pdf
          #  rm -f html.txt
          #  # make sure that long lines are split if they exceed 20 words
          #  fold -sw 90 ${{ github.event.inputs.file2compile }}_out.txt > html.txt
          #  echo "<span style='color:blue;'>FATAL LATEX COMPILATION ERROR(s)</span><br><br>" > ${{ github.event.inputs.file2compile }}.html
          #  echo "<i>To view full GitHub Actions output, click on item at top of list here:</i><br>" >> ${{ github.event.inputs.file2compile }}.html
          #  echo "<i>https://github.com/${{ github.repository }}/actions</i><br>" >> ${{ github.event.inputs.file2compile }}.html
          #  echo "<hr><br>" >> ${{ github.event.inputs.file2compile }}.html
          #  sed ':a;N;$!ba;s/\n/<br>/g;s/ /\&nbsp;/g' html.txt >> ${{ github.event.inputs.file2compile }}.html
          #  htmldoc --left 0.4in --right 0.3in --top 0.2in --bottom 0.3in --continuous -f ${{ github.event.inputs.file2compile }}.pdf ${{ github.event.inputs.file2compile }}.html
        continue-on-error: true
        
      - name: Upload PDF file
        id: uploadPdf
        uses: actions/upload-artifact@v4
        with: 
          name: PDF
          path: "${{ github.event.inputs.file2compile }}.pdf"
        continue-on-error: true
         
      - name: Publish PDF to repo
        id: releasePdf
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          file_pattern: '${{ github.event.inputs.file2compile }}.pdf'
          commit_message: 'Newly compiled PDF'
        continue-on-error: true

      - name: Upload compilation output file
        uses: actions/upload-artifact@v4
        #if: ${{ always() && hashFiles(env.OUTFILE) }}
        with: 
          name: compileOutput
          path: "${{ github.event.inputs.file2compile }}_out.txt"
        continue-on-error: true
        
      - name: Publish compilation output to repo
        id: releaseOutfile
        uses: stefanzweifel/git-auto-commit-action@v5
        #if: ${{ always() && hashFiles(env.OUTFILE) }}
        with:
          file_pattern: '${{ github.event.inputs.file2compile }}_*.*'
          commit_message: 'Newly created compilation output file'
        continue-on-error: true
