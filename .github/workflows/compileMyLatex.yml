name: Build LaTeX document and Release PDF
# Version: 07142024
#
# Is executed at gooTeX script's prompt. 
# ############################
#      Pamela M. Marcum      #
#  first created: 07/14/2024 #
# ############################
# Controls when the action will run.
# https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions
# https://mrturkmen.com/posts/build-release-latex/
# https://github.com/moderncv/debian-texlive-docker/pkgs/container/debian-texlive-docker
# https://github.com/SakulFlee/GitHub-Action-LaTeX
# https://tex.stackexchange.com/questions/166658/pdflatex-commandline-hide-compilation-output
on:
  workflow_dispatch:
    inputs: 
      file2compile:
         description: "Name of .tex file to compile, without the .tex part"
         required: true
         default: "main"
jobs:
  # followed: https://dev.to/dessygil/
  #   how-to-automatically-update-resume-on-your-personal-site-from-overleaf-1fld
  build_latex:
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      # Give the default GITHUB_TOKEN write permission to commit and push the changed files back to the repository.
      contents: write
      
    steps:
      - name: Clone repo
        uses: actions/checkout@v4

      - name: Remove old status note and pdf file
        id: removeOldStatusAndPdf
        run: |
          rm -f "${{ github.event.inputs.file2compile }}_out.txt"
          rm -f "${{ github.event.inputs.file2compile }}.pdf"
          
      - name: Commit the modified folder and put the change
        run: |
          git config --global user.email "email@gmail.com"
          git config --global user.name "github actions"
          git add .
          git commit -m "Removing previous status and pdf files"
          git push
        continue-on-error: true
                  
      - name: Install TexLive
        id: install
        uses: teatimeguest/setup-texlive-action@v3
        with:
          packages: |
            scheme-basic
            collection-mathscience
          cache: true
        continue-on-error: true

      - name: Compile latex file
        id: compilation
        run: |
          pdflatex --interaction=nonstopmode --file-line-error ${{ github.event.inputs.file2compile }}.tex > out.txt
          bibtex ${{ github.event.inputs.file2compile }}.aux > out.txt
          pdflatex --interaction=nonstopmode --file-line-error ${{ github.event.inputs.file2compile }}.tex > out.txt
          pdflatex --interaction=nonstopmode --file-line-error ${{ github.event.inputs.file2compile }}.tex > out.txt
          rm -f ${{ github.event.inputs.file2compile }}.aux ${{ github.event.inputs.file2compile }}.bbl ${{ github.event.inputs.file2compile }}.blg
          echo "============================================"
          echo ""
          cat out.txt
          echo ""
          echo "==========================================="
          echo ""
          cat ${{ github.event.inputs.file2compile }}.log

      - name: Get timestamp
        id: date
        run: |
          echo "TIMESTAMP=$(date +'%Y-%m-%dT%H:%M:%SZ') $(($(date +%s%N)/1000000))" >> $GITHUB_ENV
        continue-on-error: true
        
      - name: Capture compilation output
        id: compileWarnings
        # remove lines in the output that are unrelated to the latex compilation itself
        # First, move lines that should have been the ending of the previous line, to the end of that previous line
        run: |
          # determine if the pdf file was created in the above compilation 
          # The below smooshes the entire output file together as a single line by replacing the end-of-line with
          # a special character (\x0), removes extra white space, removes white space preceding and proceeding colons, 
          # and performs replacements using the special character to insure that each error or warning appears on a single 
          # line and does not spill over into a separate line.
          echo "-----------------------------------------------------"
          echo "       FULL, UNPROCESSED COMPILATION OUTPUT"
          echo "-----------------------------------------------------"
          mv ${{ github.event.inputs.file2compile }}.log compileout.txt
          cat compileout.txt
          echo "-----------------------------------------------------"
          echo "-----------------------------------------------------"
          sed ':a;N;$!ba;s/\n/\x0/g' compileout.txt | \
            sed -r 's/\x0+/\x0/g' | \
            sed -r 's/  */ /g' | \
            sed -r 's/ *\x0 */\x0 /g' | \
            sed -r 's/\ *\: */\: /g' | \
            sed -r 's/\[\]//g' | \
            sed -r 's/\$\$*//g' | \
            sed -r 's/\|//g' | \
            sed -r 's/\x0\x0*/\x0/g' | \
            sed -r 's/\x0+([a-zA-Z ]+)\:/\n\1\:/g' | \
            sed -r 's/undefined control sequence\.\x0/undefined control sequence\. /gi' | \
            sed -r 's/\.\x0/\.\n/g' | \
            sed -r 's/\x0+//g' | \
            sed -r 's/(lines [0-9\-]+) *\(/\1\n\(/g' | \
            sed -r 's/(\[[0-9]+\]) *\(/\1\n\(/g' | \
            sed -r 's/^ *//;s/ *$//' > allout.txt
          # put in a timestamp at the top
          echo "${{ env.TIMESTAMP }}" > tout.txt
          echo "OUTFILE=${{ github.event.inputs.file2compile }}_out.txt" >> $GITHUB_ENV
          echo "PDFFILE=${{ github.event.inputs.file2compile }}.pdf" >> $GITHUB_ENV
          # display all the errors
          echo "" >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          echo "              ERRORS IN ${{  github.event.inputs.file2compile }}.tex" >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          # The below pulls out only those lines that are directly related to warnings and errors within the .tex file 
          # This step is why we needed everything related to a given error to appear in a single line and did the formatting above.
          # https://stackoverflow.com/questions/75534451/using-grep-output-as-pattern-for-a-second-grep
          grep -i 'error.*: ${{ github.event.inputs.file2compile }}.tex' allout.txt > tmptmp.txt || touch tmptmp.txt 
          sort tmptmp.txt | uniq > errors.txt
          rm -f tmptmp.txt
          # https://stackoverflow.com/questions/57788813/grep-return-0-if-no-match
          # squash.io/extracting=numbers-from-strings-in-bash
          # https://stackoverflow.com/questions/17883661/how-to-extract-numbers-from-a-string
          # https://stackoverflow.com/questions/2624300/save-part-of-matching-pattern-to-variable
          while IFS= read -r line; do
            echo $line >> tout.txt
            linenum=$(echo $line | sed 's/^.*: \([0-9]*\):.*/\1/')
            head -n $linenum ${{ github.event.inputs.file2compile }}.tex | tail -1 >> tout.txt
            echo "-------------------------------------------------------------------------" >> tout.txt
          done < errors.txt
          # determine if there were no errors, meaning that errors.txt is empty file. If so, place
          # the word none under the banner of this section in output file. But if there were errors, 
          # then remove the pdf file so that the pdf file that gets shown in gooTeX is the compilation errors
          # rather than a mangled pdf. 
          if [ $(wc -c < "errors.txt") -eq 0 ]; then
            echo "      none" >> tout.txt
          else
            rm -f ${{ github.event.inputs.file2compile }}.pdf
            touch thereAreErrors.txt
          fi
          grep -i 'warning.*: ${{ github.event.inputs.file2compile }}.tex' allout.txt > tmptmp.txt || touch tmptmp.txt
          sort tmptmp.txt | uniq > warnings.txt
          rm -f tmptmp.txt
          echo "" >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          echo "              WARNINGS IN ${{  github.event.inputs.file2compile }}.tex" >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          while IFS= read -r line; do
            echo $line >> tout.txt
            linenum=$(echo $line | sed 's/^.*: \([0-9]*\):.*/\1/')
            head -n $linenum ${{ github.event.inputs.file2compile }}.tex | tail -1 >> tout.txt
            echo "-------------------------------------------------------------------------" >> tout.txt
          done < warnings.txt
          if [ $(wc -c < "warnings.txt") -eq 0 ]; then
            echo "      none" >> tout.txt
          fi
          echo "" >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          echo "              CITATION ISSUES IN ${{  github.event.inputs.file2compile }}.tex " >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          # now look for problems with the bibliography. In the first pass through the compilation, every citation will raise a warning flag.  But
          # eventually, those warnings will be resolved except for citations that have typos in the .tex file and/or are missing from the .bib file. 
          # The below gets a list of all citation warnings, and then figures out if any of the errors are unresolved, which would be the case if 
          # the same error appears 6 times (the number of passes can be changed as one of the input options to tectonic, though, so to be safe, let's
          # raise the issue if a citation warning appears at least 3 times. 
          # https://stackoverflow.com/questions/46324444/grep-for-words-containing-both-uppercase-and-lowercase-letters
          # https://www.tutorialspoint.com/count-duplicate-lines-in-a-text-file-on-linux
          # https://www.baeldung.com/linux/count-duplicated-lines-text  
          # https://stackoverflow.com/questions/45704484/pipelining-cut-sort-uniq
          grep -e '[eE]rror' -e '[wW]arning' allout.txt > tmptmp1.txt || touch tmptmp1.txt
          grep -i 'find.*database entry' tmptmp1.txt > tmptmp2.txt || touch tmptmp2.txt
          grep -Eo '"[a-zA-Z _0-9\-\+]+"' tmptmp2.txt > tmptmp3.txt || touch tmptmp3.txt
          cat tmptmp3.txt | sed -r 's/"//g' > tmptmp4.txt
          sort tmptmp4.txt | uniq >> tout.txt
          if [ $(wc -c < "tmptmp4.txt") -eq 0 ]; then
            echo "      none" >> tout.txt
          fi
          rm -f tmptmp*.txt
          echo "" >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          echo "              ERRORS WITH the .BIB FILE" >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          grep -e '[eE]rror' -e '[wW]arning' allout.txt > tmptmp1.txt || touch tmptmp1.txt
          grep -e ': ${{ github.event.inputs.file2compile }}.bbl' tmptmp1.txt > tmptmp2.txt || touch tmptmp2.txt
          sort  tmptmp2.txt | uniq >> tout.txt
          if [ $(wc -c < "tmptmp2.txt") -eq 0 ]; then
            echo "      none" >> tout.txt
          fi
          rm -f tmptmp*.txt
          echo "" >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          echo "              LIST OF REFERENCES IN ${{ github.event.inputs.file2compile }}.tex" >> tout.txt
          echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" >> tout.txt
          grep -e '[eE]rror' -e '[wW]arning' allout.txt > tmptmp1.txt || touch tmptmp1.txt
          grep -i ': citation' tmptmp1.txt > tmptmp2.txt || touch tmptmp2.txt
          grep -i 'undefined' tmptmp2.txt > tmptmp3.txt || touch tmptmp3.txt
          grep -Eo '`[^ ]+' tmptmp3.txt > tmptmp4.txt || touch tmptmp4.txt
          cat tmptmp4.txt | sed -r 's/`//g' | sed -r "s/'//g" > tmptmp5.txt
          sort tmptmp5.txt | uniq >> tout.txt
          if [ $(wc -c < "tmptmp5.txt") -eq 0 ]; then
            echo "      none" >> tout.txt
          fi  
          rm -f tmptmp*.txt
          mv tout.txt ${{ github.event.inputs.file2compile }}_out.txt
        continue-on-error: true

      - name: Convert errors to PDF file
        if: ${{ always() && hashFiles('thereAreErrors.txt') }}
        run: |
          # install htmldoc, which apparently is not an inherent command in Ubuntu
          sudo apt-get install htmldoc -y
          # create a .html file from the out.txt file, then convert the html to pdf
          rm -f html.txt
          # make sure that long lines are split if they exceed 20 words
          fold -sw 90 ${{ github.event.inputs.file2compile }}_out.txt > html.txt
          echo "<span style='color:blue;'>FATAL LATEX COMPILATION ERROR(s)</span><br><br>" > ${{ github.event.inputs.file2compile }}.html
          echo "<i>To view full GitHub Actions output, click on item at top of list here:</i><br>" >> ${{ github.event.inputs.file2compile }}.html
          echo "<i>https://github.com/${{ github.repository }}/actions</i><br>" >> ${{ github.event.inputs.file2compile }}.html
          echo "<hr><br>" >> ${{ github.event.inputs.file2compile }}.html
          sed ':a;N;$!ba;s/\n/<br>/g;s/ /\&nbsp;/g' html.txt >> ${{ github.event.inputs.file2compile }}.html
          htmldoc --left 0.4in --right 0.3in --top 0.2in --bottom 0.3in --continuous -f ${{ github.event.inputs.file2compile }}.pdf ${{ github.event.inputs.file2compile }}.html
        continue-on-error: true
        
      - name: Upload PDF file
        id: uploadPdf
        uses: actions/upload-artifact@v4
        if: ${{ always() && hashFiles(env.PDFFILE) }}
        with: 
          name: PDF
          path: "${{ github.event.inputs.file2compile }}.pdf"
        continue-on-error: true
         
      - name: Publish PDF to repo
        id: releasePdf
        uses: stefanzweifel/git-auto-commit-action@v5
        if: ${{ always() && hashFiles(env.PDFFILE) }}
        with:
          file_pattern: '${{ github.event.inputs.file2compile }}.pdf'
          commit_message: 'Newly compiled PDF'
        continue-on-error: true

      - name: Upload compilation output file
        uses: actions/upload-artifact@v4
        if: ${{ always() && hashFiles(env.OUTFILE) }}
        with: 
          name: compileOutput
          path: "${{ github.event.inputs.file2compile }}_out.txt"
        continue-on-error: true
        
      - name: Publish compilation output to repo
        id: releaseOutfile
        uses: stefanzweifel/git-auto-commit-action@v5
        if: ${{ always() && hashFiles(env.OUTFILE) }}
        with:
          file_pattern: '${{ github.event.inputs.file2compile }}_out.txt'
          commit_message: 'Newly created compilation output file'
        continue-on-error: true

